Name – VEDANT DHADANGE
PRN   –  230944520099   


1) create a multi-threaded application by using Thread pool. Create 2 threads. each thread should display characters from A to J. [make sure while one thread executes, other thread should not interfere]

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

class MyApp implements Runnable {

	public void run() {
		disp();
	}
	
	synchronized void disp() {
		for (char c='A'; c<='J'; c++) {
			System.out.println(Thread.currentThread().getName()+"\t\t"+c);
		}
	}
	
}

public class First
{
	public static void main(String args[]) {
		ExecutorService exse = Executors.newFixedThreadPool(2);
		
		MyApp myapp = new MyApp();
		
		exse.execute(myapp);
		exse.execute(myapp);
		exse.shutdown();
	}
}

pool-1-thread-1		A
pool-1-thread-1		B
pool-1-thread-1		C
pool-1-thread-1		D
pool-1-thread-1		E
pool-1-thread-1		F
pool-1-thread-1		G
pool-1-thread-1		H
pool-1-thread-1		I
pool-1-thread-1		J
pool-1-thread-2		A
pool-1-thread-2		B
pool-1-thread-2		C
pool-1-thread-2		D
pool-1-thread-2		E
pool-1-thread-2		F
pool-1-thread-2		G
pool-1-thread-2		H
pool-1-thread-2		I
pool-1-thread-2		J


 
2) create a multi-threaded application by using Thread pool. Create 2 threads. each thread should display numbers from 1 to 10. [make sure while one thread executes, other thread should not interfere.] Also, when first thread displays nos. from 1 to 5 it should release the lock and allow other thread to display nos. from 1 to 5 and then previous thread will display nos. from 6 to 10 and so on.

import java.util.concurrent.*;
import java.util.concurrent.locks.*;

class MyApp implements Runnable {
	
	ReentrantLock mylock=new ReentrantLock();
	Condition value=mylock.newCondition();
	
	public void run() {
		disp();
	}
	
	void disp() {
		mylock.lock();
		try {
			for (int i=1; i<=10; i++) {
				System.out.println(Thread.currentThread().getName()+"\t\t"+i);
				if (i==5) {
					value.signal();
					value.await();
				}
				if (i==10) {
					value.signal();
				}
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		} finally {
			mylock.unlock();
		}
	}
}

public class First
{
	public static void main(String args[]) {
		ExecutorService exse = Executors.newFixedThreadPool(2);
		
		MyApp myapp = new MyApp();
		
		exse.execute(myapp);
		exse.execute(myapp);
		
		exse.shutdown();
	}
}

pool-1-thread-1		1
pool-1-thread-1		2
pool-1-thread-1		3
pool-1-thread-1		4
pool-1-thread-1		5
pool-1-thread-2		1
pool-1-thread-2		2
pool-1-thread-2		3
pool-1-thread-2		4
pool-1-thread-2		5
pool-1-thread-1		6
pool-1-thread-1		7
pool-1-thread-1		8
pool-1-thread-1		9
pool-1-thread-1		10
pool-1-thread-2		6
pool-1-thread-2		7
pool-1-thread-2		8
pool-1-thread-2		9
pool-1-thread-2		10


 
3) create a multi-threaded application by using Thread pool and ReentrantLock (explicit locking). create 2 threads. each thread should display characters from A to J. [make sure while one thread executes, other thread should not interfere]

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.locks.ReentrantLock;

class MyApp implements Runnable {
	
	ReentrantLock lock = new ReentrantLock();

	public void run() {
		disp();
	}
	
	void disp() {
		lock.lock();
		for (char c='A'; c<='J'; c++) {
			System.out.println(Thread.currentThread().getName()+"\t\t"+c);
		}
		lock.unlock();
	}
	
}

public class First
{
	public static void main(String args[]) {
		ExecutorService exse = Executors.newFixedThreadPool(2);
		
		MyApp myapp = new MyApp();
		
		exse.execute(myapp);
		exse.execute(myapp);
		exse.shutdown();
	}
}

pool-1-thread-1		A
pool-1-thread-1		B
pool-1-thread-1		C
pool-1-thread-1		D
pool-1-thread-1		E
pool-1-thread-1		F
pool-1-thread-1		G
pool-1-thread-1		H
pool-1-thread-1		I
pool-1-thread-1		J
pool-1-thread-2		A
pool-1-thread-2		B
pool-1-thread-2		C
pool-1-thread-2		D
pool-1-thread-2		E
pool-1-thread-2		F
pool-1-thread-2		G
pool-1-thread-2		H
pool-1-thread-2		I
pool-1-thread-2		J


 
4) create a multi-threaded application by using Thread pool and ReentrantLock. create 2 threads. each thread should display numbers from 1 to 10. [ make sure while one thread executes, other thread should not interfere] Also, when first thread displays nos. from 1 to 5 it should release the lock and allow other thread to display nos. from 1 to 5 and then previous thread will display nos. from 6 to 10 and so on.

import java.util.concurrent.*;
import java.util.concurrent.locks.*;

class MyApp implements Runnable {
	
	ReentrantLock mylock=new ReentrantLock();
	Condition value=mylock.newCondition();
	
	public void run() {
		disp();
	}
	
	void disp() {
		mylock.lock();
		try {
			for (int i=1; i<=10; i++) {
				System.out.println(Thread.currentThread().getName()+"\t\t"+i);
				if (i==5) {
					value.signal();
					value.await();
				}
				if (i==10) {
					value.signal();
				}
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		} finally {
			mylock.unlock();
		}
	}
}

public class First
{
	public static void main(String args[]) {
		ExecutorService exse = Executors.newFixedThreadPool(2);
		
		MyApp myapp = new MyApp();
		
		exse.execute(myapp);
		exse.execute(myapp);
		
		exse.shutdown();
	}
}

pool-1-thread-1		1
pool-1-thread-1		2
pool-1-thread-1		3
pool-1-thread-1		4
pool-1-thread-1		5
pool-1-thread-2		1
pool-1-thread-2		2
pool-1-thread-2		3
pool-1-thread-2		4
pool-1-thread-2		5
pool-1-thread-1		6
pool-1-thread-1		7
pool-1-thread-1		8
pool-1-thread-1		9
pool-1-thread-1		10
pool-1-thread-2		6
pool-1-thread-2		7
pool-1-thread-2		8
pool-1-thread-2		9
pool-1-thread-2		10



